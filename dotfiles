#!/usr/bin/python

'''dotfiles keeps your ~/.* synchronized across machines.
Usage:

dotfiles init REPO

  Initializes dotfiles using REPO. REPO is where the master copy of
  your dotfiles will be stored.

dotfiles install REPO

  Installs dotfiles from REPO into your ~ on this
  machine. Creates ~/.dotfiles/ if it does not exist; complains and
  exits with error if a ~/.dotfiles does exist.

  Pulls files from REPO into ~/.dotfiles/...

  FIXME: Needs to deal with existing files in a sane way.

dotfiles add DOTFILE

  If DOTFILE is not under ~, complain and exit with error.

  *Move* DOTFILE into ~/.dotfiles and create a symlink from the
  original file to the ~/.dotfiles version. If DOTFILE is in a
  subdir, the subdirs will be created under ~/.dotfiles. Adds
  DOTFILE to the REPO (locally: it does not do the push/checkin).

  If DOTFILE is a directory, everything under the directory will be
  placed under dotfiles control. The directory itself will become a
  symlink into the REPO. If you do not want to control the entire
  directory, pick and choose the files you want to control. Mixing and
  matching is probably a bad idea.

dotfiles push COMMIT-MSG

  Sends local changes to REPO. Similar semantics to git push, svn ci
  -- e.g. behavior if local is out of date w.r.t REPO.

dotfiles pull

  Fetches updates from REPO. Similar semantics to git pull, svn up
  -- e.g. behavior when merge required.

  When new files appear, it creates links from ~/... to
  ~/.dotfiles/...

  FIXME: Deal with existing files of the same name in a sane
  way. (See above, same problem.)
'''

__version__ = "0.2"
__date__ = "2009-09-02"
__author__ = "Brian St. Pierre (http://bstpierre.org/)"
__copyright__ = "Copyright 2009, Brian St. Pierre"
__license__ = "MIT"


import optparse
import os
import subprocess
import sys

# This is where we store our control info.
_DOTFILES_DIR = os.path.join(os.environ.get('HOME', ''),
                             '.dotfiles')

# This is where copies of the dotfiles live (e.g. .emacs).
_LOCAL_REPO_DIR = os.path.join(_DOTFILES_DIR, 'repo')


def _maybe_warn(link):
    '''Print a warning about the fact that link exists.

    Unless it is in a parent directory that is linked into the
    repo.'''

    home = os.environ.get('HOME', None)
    if not home:
        return

    dir = os.path.dirname(link)
    while dir not in ['/', home]:
        if os.path.islink(dir):
            target = os.readlink(dir)
            if _LOCAL_REPO_DIR in target:
                # A parent dir is pointing into the repo, don't warn.
                return
        dir = os.path.dirname(dir)
    print 'WARNING: %s exists, skipping' % link


def _make_links_to_repo(warn_on_existing_links=False):
    dirs = ['']
    while len(dirs):
        dir = dirs.pop()
        for f in os.listdir(os.path.join(_LOCAL_REPO_DIR, dir)):
            if f == '.git':
                continue
            path = os.path.join(_LOCAL_REPO_DIR, dir, f)
            if os.path.isdir(path):
                dirs.append(os.path.join(dir, f))
                continue
            if os.path.isfile(path):
                linkdir = os.path.join(os.environ.get('HOME', ''),
                                       dir)
                if not os.path.isdir(linkdir):
                    os.makedirs(linkdir)
                link = os.path.join(linkdir, f)
                if os.path.exists(link):
                    # If warn_on_existing_links is set, we warn (and
                    # skip the file).
                    #
                    # If the file is not a symlink, we warn (and skip
                    # the file).
                    #
                    # Otherwise the file is a symlink and we can just
                    # ignore it -- assume dotfiles already controls
                    # it.
                    if (not os.path.islink(link) or
                        warn_on_existing_links):
                        _maybe_warn(link)
                    continue
                os.symlink(path, link)


def dotfiles_init(*args):
    if len(args) != 1:
        print __doc__
        return 1

    repo = args[0]

    if not os.path.exists(repo):
        os.makedirs(repo)

    retcode = subprocess.call('git init', cwd=repo, shell=True)
    if retcode == 0:
        retcode = subprocess.call('git commit --allow-empty '+
                                  '-m"New dotfiles repository"',
                                  cwd=repo,
                                  shell=True)

    return retcode


def dotfiles_install(*args):
    '''Installs dotfiles from REPO into your ~ on this
    machine. Creates ~/.dotfiles/ if it does not exist; complains and
    exits with error if a ~/.dotfiles does exist.

    Pulls files from REPO into ~/.dotfiles/...
    '''

    if len(args) != 1:
        print __doc__
        return 1

    repo = args[0]

    if os.path.exists(_DOTFILES_DIR):
        print 'error: dotfiles control dir "%s" exists already' % (
            _DOTFILES_DIR)
        return 1

    os.makedirs(_DOTFILES_DIR)
    retcode = subprocess.call('git clone %s %s' % (
                                  repo, _LOCAL_REPO_DIR),
                              shell=True)

    _make_links_to_repo(warn_on_existing_links=True)

    return retcode


def dotfiles_add(*args):
    if len(args) < 1:
        print __doc__
        return 1

    home = os.environ.get('HOME', None)
    if not home:
        print 'error: $HOME is not set, exiting'
        return 1

    for file in args:
        if file.find(home) != 0:
            # Maybe the name is relative to $HOME?
            if not os.path.isfile(os.path.join(home, file)):
                print 'WARNING: %s is not under $HOME (%s), skipping' % (
                    file, home)
                continue
            else:
                file = os.path.join(home, file)
                print 'INFO: using %s' % os.path.join(home, file)
        filename = file.replace(home, '').strip(os.path.sep)
        repofile = os.path.join(_LOCAL_REPO_DIR, filename)
        repodir = os.path.dirname(repofile)
        if not os.path.exists(repodir):
            os.makedirs(repodir)
        print 'dotfiles_add', filename, repofile, file
        os.rename(file, repofile)
        os.symlink(repofile, file)
        retcode = subprocess.call(
            'git add ' + filename,
            cwd=_LOCAL_REPO_DIR,
            shell=True)
        if retcode != 0:
            print 'error: git add failed adding %s, ' % filename + \
                  'your dotfiles are probably in an inconsistent state'
            return retcode


def dotfiles_push(*args):
    if len(args) != 1:
        print __doc__
        return 1

    msg = args[0]
    retcode = subprocess.call(
        'git commit -a -m"%s"' % (msg, ),
        cwd=_LOCAL_REPO_DIR,
        shell=True)
    if retcode != 0:
        print 'error: git commit failed, your dotfiles ' + \
              'are probably in an inconsistent state'
        return retcode

    retcode = subprocess.call(
        'git push',
        cwd=_LOCAL_REPO_DIR,
        shell=True)
    if retcode != 0:
        print 'error: git push failed, your dotfiles ' + \
              'are probably in an inconsistent state'
        return retcode

    return retcode


def dotfiles_pull(*args):
    if len(args):
        print __doc__
        return 1

    retcode = subprocess.call(
        'git pull',
        cwd=_LOCAL_REPO_DIR,
        shell=True)
    if retcode != 0:
        print 'error: git pull failed, your dotfiles ' + \
              'are probably in an inconsistent state'
        return retcode

    _make_links_to_repo(warn_on_existing_links=False)

    return retcode


def main():
    parser = optparse.OptionParser(usage=__doc__)

    options, remaining = parser.parse_args(sys.argv)

    if len(remaining) < 2:
        parser.print_usage()
        sys.exit(1)

    mode = remaining[1]
    handler = globals().get('dotfiles_' + mode, None)
    if handler:
        status = handler(*remaining[2:])
    else:
        print 'dotfiles: unknown mode "%s"' % mode
        status = 1

    sys.exit(status)


if __name__ == '__main__':
    main()
